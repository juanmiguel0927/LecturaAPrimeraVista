<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lectura a Primera Vista</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css?family=Inter:wght@400;600;700;800&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #111827; }
        #loading-message { position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%); z-index: 1000; background-color: #1f2937; color: white; padding: 2rem; border-radius: 0.75rem; font-size: 1.5rem; font-weight: bold; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 100; }
        .modal-content { background-color: #374151; color: #d1d5db; padding: 2rem; border-radius: 1rem; max-width: 90%; width: 500px; max-height: 90%; overflow-y: auto; position: relative; }
        .modal-content h2 { margin-bottom: 1.5rem; }
        .modal-content p, .modal-content ul { line-height: 1.6; }
        .modal-content strong { color: #34d399; }
        .modal-content ul { list-style-position: inside; padding-left: 1rem; }
        .modal-close { position: absolute; top: 1rem; right: 1rem; font-size: 1.5rem; cursor: pointer; }
        .stave-container { position: relative; }
        .tutorial-highlight-overlay { position: fixed; top: 0; left: 0; pointer-events: none; z-index: 99; transition: all 0.5s ease-in-out; box-shadow: 0 0 0 0 transparent; border-radius: 1rem; }
        .pre-roll-message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; display: flex; align-items: center; justify-content: center; flex-direction: column; color: #34d399; font-size: 3rem; font-weight: 800; text-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        .pre-roll-message-count { font-size: 5rem; }
        .tutorial-step.active { color: #d1d5db; }
        .radio-label { display: inline-block; background-color: #4b5563; padding: 0.5rem 1rem; border-radius: 0.5rem; cursor: pointer; transition: all 0.2s ease-in-out; border: 2px solid transparent; }
        input[type="radio"]:checked + .radio-label { background-color: #374151; color: #34d399; border-color: #34d399; }
        .control-item { display: flex; flex-direction: column; align-items: flex-start; gap: 0.5rem; }
        @media (min-width: 640px) {
            .control-item { flex-direction: row; align-items: center; justify-content: space-between; width: 100%;}
        }
        
        /* --- Fullscreen Styles --- */
        #stave-viewer:fullscreen {
            background-color: #f8fafc; /* Same as stave bg */
            padding: 1rem;
        }
        #stave-viewer:fullscreen #stave-container {
            height: 100%;
            width: 100%;
        }
        #stave-viewer:fullscreen #fullscreen-toggle {
            opacity: 1;
        }

    </style>
</head>
<body class="bg-zinc-900 text-white flex flex-col items-center p-4 min-h-screen">
    <div id="loading-message">Cargando...</div>
    <div id="main-content" class="hidden bg-zinc-800 rounded-2xl text-center border-2 shadow-2xl p-6 md:p-10 w-full max-w-5xl border-emerald-500">
        <h1 class="text-4xl md:text-5xl font-extrabold text-emerald-400 mb-2 drop-shadow-md">Lectura a Primera Vista</h1>
        <p class="text-zinc-500 text-sm mb-4">Aplicación realizada por Juan Miguel Rios Redondo</p>
        <p class="text-zinc-400 text-lg md:text-xl mb-6">Ejercicios para guitarra</p>
        <div id="exercise-type-control" class="flex items-center justify-center space-x-2 mb-6">
            <span class="text-zinc-300 font-bold mr-2">Tipo de Ejercicio:</span>
            <div>
                <input type="radio" name="exerciseType" id="type-melodia" value="melodia" class="hidden" checked>
                <label for="type-melodia" class="radio-label">Melodía</label>
            </div>
            <div>
                <input type="radio" name="exerciseType" id="type-armonia" value="armonia" class="hidden">
                <label for="type-armonia" class="radio-label">Armonía</label>
            </div>
        </div>
        <div id="controls-container" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-x-6 gap-y-4 mb-8">
            <div id="harmony-options-container" class="control-item hidden">
                <label for="notes-per-chord" class="text-zinc-300 whitespace-nowrap">Notas:</label>
                <select id="notes-per-chord" class="p-2 w-full rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                    <option value="2">2</option><option value="3" selected>3</option><option value="4">4</option>
                </select>
            </div>
            <div id="interval-options-container" class="control-item hidden">
                <label for="interval-select" class="text-zinc-300 whitespace-nowrap">Intervalo:</label>
                <select id="interval-select" class="p-2 w-full rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                    <option value="0" selected>Todos</option>
                    <option value="1">2da</option><option value="2">3ra</option><option value="3">4ta</option>
                    <option value="4">5ta</option><option value="5">6ta</option><option value="6">7ma</option><option value="7">8va</option>
                </select>
            </div>
            <div id="triad-options-container" class="control-item hidden">
                <label for="triad-select" class="text-zinc-300 whitespace-nowrap">Tipo de Acorde:</label>
                <select id="triad-select" class="p-2 w-full rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                    <option value="all" selected>Todos</option>
                    <option value="triad_fundamental">Tríada Fundamental</option>
                    <option value="triad_inv1">Tríada 1ra Inv.</option>
                    <option value="triad_inv2">Tríada 2da Inv.</option>
                    <option value="sus2_fundamental">Acordes Sus2</option>
                    <option value="sus4_fundamental">Acordes Sus4</option>
                </select>
            </div>
            <div id="triad-position-container" class="control-item hidden">
                <label for="triad-position-select" class="text-zinc-300 whitespace-nowrap">Posición:</label>
                <select id="triad-position-select" class="p-2 w-full rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                    <option value="all" selected>Todas</option>
                    <option value="cerrada">Cerrada</option>
                    <option value="abierta">Abierta</option>
                </select>
            </div>
             <div id="quad-options-container" class="control-item hidden">
                <label for="quad-voicing-select" class="text-zinc-300 whitespace-nowrap">Voicing:</label>
                <select id="quad-voicing-select" class="p-2 w-full rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                    <!-- Options will be populated by JS -->
                </select>
            </div>
            <div class="control-item">
                <label for="tempo" class="text-zinc-300 whitespace-nowrap">Tempo (BPM):</label>
                <input type="number" id="tempo" value="60" min="1" class="w-full p-2 text-center rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500"/>
            </div>
            <div class="control-item">
                <label for="clef-select" class="text-zinc-300 whitespace-nowrap">Clave:</label>
                <select id="clef-select" class="p-2 w-full rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                    <option value="G" selected>Sol</option><option value="F">Fa</option><option value="C">Do</option>
                </select>
            </div>
             <div id="key-signature-container" class="control-item">
                <label for="key-signature-select" class="text-zinc-300 whitespace-nowrap">Armadura:</label>
                <select id="key-signature-select" class="p-2 w-full rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                    <option value="C">Do M / La m (0)</option>
                    <optgroup label="Sostenidos">
                        <option value="G">Sol M / Mi m (1♯)</option>
                        <option value="D">Re M / Si m (2♯)</option>
                        <option value="A">La M / Fa♯ m (3♯)</option>
                        <option value="E">Mi M / Do♯ m (4♯)</option>
                        <option value="B">Si M / Sol♯ m (5♯)</option>
                        <option value="F#">Fa♯ M / Re♯ m (6♯)</option>
                        <option value="C#">Do♯ M / La♯ m (7♯)</option>
                    </optgroup>
                    <optgroup label="Bemoles">
                        <option value="F">Fa M / Re m (1♭)</option>
                        <option value="Bb">Si♭ M / Sol m (2♭)</option>
                        <option value="Eb">Mi♭ M / Do m (3♭)</option>
                        <option value="Ab">La♭ M / Fa m (4♭)</option>
                        <option value="Db">Re♭ M / Si♭ m (5♭)</option>
                        <option value="Gb">Sol♭ M / Mi♭ m (6♭)</option>
                        <option value="Cb">Do♭ M / La♭ m (7♭)</option>
                    </optgroup>
                </select>
            </div>
            <div id="time-signature-container" class="control-item">
                <label for="time-signature-select" class="text-zinc-300 whitespace-nowrap">Compás:</label>
                <select id="time-signature-select" class="p-2 w-full rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                    <option value="4/4">4/4</option><option value="3/4">3/4</option><option value="2/4">2/4</option>
                </select>
            </div>
            <div class="control-item">
                <label for="difficulty-select" class="text-zinc-300 whitespace-nowrap">Nivel:</label>
                <select id="difficulty-select" class="p-2 w-full rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                    <option value="basico">Básico</option><option value="medium">Medio</option><option value="advanced">Avanzado</option>
                </select>
            </div>
            <div class="control-item">
                <label for="measures-select" class="text-zinc-300 whitespace-nowrap">Compases:</label>
                <select id="measures-select" class="p-2 w-full rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                    <option value="5">5</option><option value="10" selected>10</option><option value="15">15</option><option value="20">20</option><option value="custom">Personalizado</option>
                </select>
            </div>
             <div id="custom-measures-input-container" class="control-item hidden">
                <label for="custom-measures-input" class="text-zinc-300 whitespace-nowrap">Nº:</label>
                <input type="number" id="custom-measures-input" value="10" placeholder="Nº" min="1" class="w-full p-2 text-center rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500"/>
            </div>
            <div class="control-item flex-row sm:justify-start gap-4">
                <div class="flex items-center gap-2">
                    <label for="show-note-names" class="text-zinc-300 whitespace-nowrap">Nombres:</label>
                    <input type="checkbox" id="show-note-names" class="w-5 h-5 rounded bg-zinc-700 text-emerald-500 border-zinc-600 focus:ring-emerald-500 focus:ring-2"/>
                </div>
                <div class="flex items-center gap-2">
                    <label for="show-guide" class="text-zinc-300 whitespace-nowrap">Guía:</label>
                    <input type="checkbox" id="show-guide" class="w-5 h-5 rounded bg-zinc-700 text-emerald-500 border-zinc-600 focus:ring-emerald-500 focus:ring-2"/>
                </div>
            </div>
            <div id="melody-note-name-options-container" class="control-item hidden">
                <label for="melody-note-name-style-select" class="text-zinc-300 whitespace-nowrap">Alteración:</label>
                <select id="melody-note-name-style-select" class="p-2 w-full rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                    <option value="con-alteracion" selected>Con Alteración</option>
                    <option value="sin-alteracion">Sin Alteración</option>
                </select>
            </div>
             <div id="cipher-type-container" class="control-item hidden">
                <label for="cipher-type-select" class="text-zinc-300 whitespace-nowrap">Cifrado:</label>
                <select id="cipher-type-select" class="p-2 w-full rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                    <option value="todos" selected>Todos</option>
                    <option value="americano">Americano</option>
                    <option value="drops">Drops</option>
                </select>
            </div>
        </div>
        <div id="change-beat-control" class="flex items-center justify-center space-x-2 mb-8">
            <label for="change-beat-select" class="text-zinc-300">Cambiar compás en tiempo:</label>
            <select id="change-beat-select" class="p-2 rounded-lg bg-zinc-700 text-white border border-zinc-600 focus:outline-none focus:ring-2 focus:ring-emerald-500">
            </select>
        </div>
        <div class="flex justify-center items-center space-x-4 mb-8">
            <button id="startStopButton" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transform hover:scale-105 transition-all duration-300">Comenzar</button>
            <button id="pauseResumeButton" class="hidden bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-full shadow-lg transform hover:scale-105 transition-all duration-300">Pausar</button>
            <button id="show-tutorial" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-full shadow-lg transform hover:scale-105 transition-all duration-300">Tutorial</button>
        </div>
        <div id="stave-viewer" class="group relative bg-zinc-700 p-2 md:p-6 rounded-lg shadow-inner mb-8 overflow-x-auto w-full">
            <div id="stave-container" class="stave-container w-full h-80 flex items-center justify-center bg-white rounded-lg shadow-md border border-zinc-600"></div>
            <button id="fullscreen-toggle" class="absolute z-10 bottom-4 right-4 p-3 rounded-full bg-gray-800 bg-opacity-60 text-white hover:bg-opacity-80 transition-all duration-300 opacity-0 group-hover:opacity-100 focus:opacity-100" title="Pantalla Completa">
                <svg id="enter-fullscreen-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/><path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/></svg>
                <svg id="exit-fullscreen-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><path d="M8 3v3a2 2 0 0 1-2 2H3"/><path d="M21 8h-3a2 2 0 0 1-2-2V3"/><path d="M3 16h3a2 2 0 0 1 2 2v3"/><path d="M16 21v-3a2 2 0 0 1 2-2h3"/></svg>
            </button>
        </div>
        <div id="displayArea" class="hidden bg-zinc-700 p-6 rounded-lg shadow-inner">
            <div class="flex justify-center items-center space-x-4">
                <span class="text-zinc-300 font-mono">Tiempo: <span id="metronomeCount" class="text-2xl font-bold ml-2 text-zinc-400">0</span></span>
                <span class="text-zinc-300 font-mono">Compases: <span id="measuresCount" class="text-xl font-bold text-sky-400">0 / 10</span></span>
            </div>
        </div>
        <div id="pre-roll-message" class="pre-roll-message hidden">
            <span>Preparación</span><span id="preRollCount" class="pre-roll-message-count"></span>
        </div>
    </div>
    <div id="tutorial-modal" class="modal-overlay hidden">
        <div class="modal-content text-left">
            <span class="modal-close" id="close-modal">×</span>
            <div id="tutorial-steps-container"></div>
            <div class="flex justify-between items-center mt-4">
                <button id="prev-tutorial-step" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-full shadow-lg">Anterior</button>
                <span id="tutorial-step-counter" class="text-zinc-400"></span>
                <button id="next-tutorial-step" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 px-4 rounded-full shadow-lg">Siguiente</button>
            </div>
        </div>
    </div>
    <div id="tutorial-highlight-overlay" class="tutorial-highlight-overlay hidden"></div>
    <script>
        // --- GLOBAL SCOPE ---
        let ui, state, audio, notesData;
        // --- INITIALIZATION ---
        window.onload = () => {
            try {
                initializeElements();
                initializeAppState();
                attachEventListeners();
                updateChangeBeatOptions();
                updateDropVoicingOptions();
                updateHarmonyControlsVisibility();
                renderStave();
                ui.loadingMessage.style.display = 'none';
                ui.mainContent.classList.remove('hidden');
            } catch (e) {
                console.error('Fatal error during initialization:', e);
                document.getElementById('loading-message').textContent = "Error al cargar. Refresca la página.";
            }
        };
                function initializeElements() {
            const get = (id) => { const el = document.getElementById(id); if (!el) throw new Error(`Element "${id}" not found.`); return el; };
            ui = {
                loadingMessage: get('loading-message'), mainContent: get('main-content'), startStopButton: get('startStopButton'),
                pauseResumeButton: get('pauseResumeButton'),
                displayArea: get('displayArea'), tempoInput: get('tempo'), metronomeCount: get('metronomeCount'),
                staveContainer: get('stave-container'), clefSelect: get('clef-select'), timeSigSelect: get('time-signature-select'),
                measuresSelect: get('measures-select'), measuresCount: get('measuresCount'), customMeasuresContainer: get('custom-measures-input-container'),
                customMeasuresInput: get('custom-measures-input'), preRollMessage: get('pre-roll-message'), difficultySelect: get('difficulty-select'),
                changeBeatSelect: get('change-beat-select'), showTutorialBtn: get('show-tutorial'), tutorialModal: get('tutorial-modal'),
                closeModalBtn: get('close-modal'), tutorialStepsContainer: get('tutorial-steps-container'), nextTutorialStepBtn: get('next-tutorial-step'),
                prevTutorialStepBtn: get('prev-tutorial-step'), tutorialStepCounter: get('tutorial-step-counter'),
                tutorialHighlight: get('tutorial-highlight-overlay'), preRollCount: get('preRollCount'), showNoteNamesToggle: get('show-note-names'),
                exerciseTypeRadios: document.querySelectorAll('input[name="exerciseType"]'), harmonyOptionsContainer: get('harmony-options-container'),
                notesPerChordSelect: get('notes-per-chord'), changeBeatContainer: get('change-beat-control'), intervalOptionsContainer: get('interval-options-container'),
                intervalSelect: get('interval-select'), triadOptionsContainer: get('triad-options-container'), triadSelect: get('triad-select'),
                triadPositionContainer: get('triad-position-container'), triadPositionSelect: get('triad-position-select'),
                quadOptionsContainer: get('quad-options-container'), quadVoicingSelect: get('quad-voicing-select'),
                keySigSelect: get('key-signature-select'), cipherTypeContainer: get('cipher-type-container'), cipherTypeSelect: get('cipher-type-select'),
                keySigContainer: get('key-signature-container'), melodyNoteNameOptionsContainer: get('melody-note-name-options-container'),
                melodyNoteNameStyleSelect: get('melody-note-name-style-select'), showGuideToggle: get('show-guide'),
                timeSigContainer: get('time-signature-container'), 
                staveViewer: get('stave-viewer'), fullscreenToggle: get('fullscreen-toggle'), enterFullscreenIcon: get('enter-fullscreen-icon'), exitFullscreenIcon: get('exit-fullscreen-icon')
            };
        }
        function initializeAppState() {
            state = { 
                exerciseType: 'melodia', notesPerChord: 3, selectedInterval: 0, selectedTriad: 'all', triadPosition: 'all',
                selectedQuadVoicing: 'all', cipherType: 'todos', melodyNoteNameStyle: 'con-alteracion',
                exerciseStarted: false, isPaused: false, metronomeTimer: null, exerciseMeasures: [], currentMeasureContent: [], 
                currentMetronomeCount: 0, timeSignatureBeats: 4, measuresChangeBeat: 4, currentMeasureIndex: -1, 
                measuresPerExercise: 10, isPreRoll: false, isPlaying: false, showNoteNames: false, keySignature: 'C',
                showGuide: false, noteStartX: 0, noteSpacing: 0, spacebarPressCount: 0, spacebarTimeout: null
            };
            audio = { context: null, lookahead: 25.0, scheduleAheadTime: 0.1, nextNoteTime: 0.0, pauseStartTime: 0.0 };
            notesData = {
                all: [], natural: [], noteToLatin: {'C':'Do','D':'Re','E':'Mi','F':'Fa','G':'Sol','A':'La','B':'Si'},
                letterToDiatonic: {'C':0,'D':1,'E':2,'F':3,'G':4,'A':5,'B':6}, clefs: {},
                allowedFourNoteChords: {
                    'C':    [{ name: 'Cmaj7', notes: ['C','E','G','B'] },{ name: 'Cm7', notes: ['C','Eb','G','Bb'] },{ name: 'C7', notes: ['C','E','G','Bb'] },{ name: 'Cm7b5', notes: ['C','Eb','Gb','Bb'] },{ name: 'C°7', notes: ['C','Eb','Gb','A'] }],
                    'C#':   [{ name: 'C#m7', notes: ['C#','E','G#','B'] },{ name: 'C#7', notes: ['C#','E#','G#','B'] },{ name: 'C#m7b5', notes: ['C#','E','G','B'] },{ name: 'C#°7', notes: ['C#','E','G','Bb'] }],
                    'Db':   [{ name: 'Dbmaj7', notes: ['Db','F','Ab','C'] },{ name: 'Dbm7', notes: ['Db','Fb','Ab','Cb'] },{ name: 'Db7', notes: ['Db','F','Ab','Cb'] },{ name: 'Db°7', notes: ['Db','Fb','Abb','A'] }],
                    'D':    [{ name: 'Dmaj7', notes: ['D','F#','A','C#'] },{ name: 'Dm7', notes: ['D','F','A','C'] },{ name: 'D7', notes: ['D','F#','A','C'] },{ name: 'Dm7b5', notes: ['D','F','Ab','C'] },{ name: 'D°7', notes: ['D','F','Ab','B'] }],
                    'Eb':   [{ name: 'Ebmaj7', notes: ['Eb','G','Bb','D'] },{ name: 'Ebm7', notes: ['Eb','Gb','Bb','Db'] },{ name: 'Eb7', notes: ['Eb','G','Bb','Db'] },{ name: 'Ebm7b5', notes: ['Eb','Gb','Bbb','Db'] },{ name: 'Eb°7', notes: ['Eb','Gb','A','C'] }],
                    'E':    [{ name: 'Emaj7', notes: ['E','G#','B','D#'] },{ name: 'Em7', notes: ['E','G','B','D'] },{ name: 'E7', notes: ['E','G#','B','D'] },{ name: 'Em7b5', notes: ['E','G','Bb','D'] },{ name: 'E°7', notes: ['E','G','Bb','Db'] }],
                    'F':    [{ name: 'Fmaj7', notes: ['F','A','C','E'] },{ name: 'Fm7', notes: ['F','Ab','C','Eb'] },{ name: 'F7', notes: ['F','A','C','Eb'] },{ name: 'Fm7b5', notes: ['F','Ab','Cb','Eb'] },{ name: 'F°7', notes: ['F','Ab','B','D'] }],
                    'F#':   [{ name: 'F#maj7', notes: ['F#','A#','C#','E#'] },{ name: 'F#m7', notes: ['F#','A','C#','E'] },{ name: 'F#7', notes: ['F#','A#','C#','E'] },{ name: 'F#m7b5', notes: ['F#','A','C','E'] },{ name: 'F#°7', notes: ['F#','A','C','Eb'] }],
                    'Gb':   [{ name: 'Gbmaj7', notes: ['Gb','Bb','Db','F'] },{ name: 'Gb7', notes: ['Gb','Bb','Db','Fb'] },{ name: 'Gb°7', notes: ['Gb','A','C','Eb'] }],
                    'G':    [{ name: 'Gmaj7', notes: ['G','B','D','F#'] },{ name: 'Gm7', notes: ['G','Bb','D','F'] },{ name: 'G7', notes: ['G','B','D','F'] },{ name: 'Gm7b5', notes: ['G','Bb','Db','F'] },{ name: 'G°7', notes: ['G','Bb','Db','E'] }],
                    'Ab':   [{ name: 'Abmaj7', notes: ['Ab','C','Eb','G'] },{ name: 'Abm7', notes: ['Ab','Cb','Eb','Gb'] },{ name: 'Ab7', notes: ['Ab','C','Eb','Gb'] },{ name: 'Abm7b5', notes: ['Ab','Cb','Ebb','Gb'] },{ name: 'Ab°7', notes: ['Ab','B','D','F'] }],
                    'A':    [{ name: 'Amaj7', notes: ['A','C#','E','G#'] },{ name: 'Am7', notes: ['A','C','E','G'] },{ name: 'A7', notes: ['A','C#','E','G'] },{ name: 'Am7b5', notes: ['A','C','Eb','G'] },{ name: 'A°7', notes: ['A','C','Eb','Gb'] }],
                    'Bb':   [{ name: 'Bbmaj7', notes: ['Bb','D','F','A'] },{ name: 'Bbm7', notes: ['Bb','Db','F','Ab'] },{ name: 'Bb7', notes: ['Bb','D','F','Ab'] },{ name: 'Bbm7b5', notes: ['Bb','Db','Fb','Ab'] },{ name: 'Bb°7', notes: ['Bb','Db','E','G'] }],
                    'B':    [{ name: 'Bmaj7', notes: ['B','D#','F#','A#'] },{ name: 'Bm7', notes: ['B','D','F#','A'] },{ name: 'B7', notes: ['B','D#','F#','A'] },{ name: 'Bm7b5', notes: ['B','D','F','A'] },{ name: 'B°7', notes: ['B','D','F','Ab'] }]
                },
                voicingsByDifficulty: { medium: { 'drop2': 'Drops 2', 'drop3': 'Drops 3' }, advanced: { 'all': 'Todos', 'drop2': 'Drops 2', 'drop3': 'Drops 3', 'drop24': 'Drops 2&4', 'drop23': 'Drops 2&3', 'doubleDrop23': 'Doble Drops 2 & Drops 3'}},
                voicingAbbreviations: { 'all': '', 'drop2': 'D2', 'drop3': 'D3', 'drop24': 'D2&4', 'drop23': 'D2&3', 'doubleDrop23': 'Dd2&D3' },
                keySignatures: {
                    'C': { notes: ['C','D','E','F','G','A','B'] }, 'G': { notes: ['G','A','B','C','D','E','F#'] },
                    'D': { notes: ['D','E','F#','G','A','B','C#'] }, 'A': { notes: ['A','B','C#','D','E','F#','G#'] },
                    'E': { notes: ['E','F#','G#','A','B','C#','D#'] }, 'B': { notes: ['B','C#','D#','E','F#','G#','A#'] },
                    'F#':{ notes: ['F#','G#','A#','B','C#','D#','E#'] }, 'C#':{ notes: ['C#','D#','E#','F#','G#','A#','B#'] },
                    'F': { notes: ['F','G','A','Bb','C','D','E'] }, 'Bb':{ notes: ['Bb','C','D','Eb','F','G','A'] },
                    'Eb':{ notes: ['Eb','F','G','Ab','Bb','C','D'] }, 'Ab':{ notes: ['Ab','Bb','C','Db','Eb','F','G'] },
                    'Db':{ notes: ['Db','Eb','F','Gb','Ab','Bb','C'] }, 'Gb':{ notes: ['Gb','Ab','Bb','Cb','Db','Eb','F'] },
                    'Cb':{ notes: ['Cb','Db','Eb','Fb','Gb','Ab','Bb'] }
                },
                sharpPositions: { 'G': [40, 55, 35, 50, 65, 45, 60], 'F': [50, 65, 45, 60, 75, 55, 70], 'C': [45, 60, 40, 55, 70, 50, 65] },
                flatPositions: { 'G': [55, 40, 60, 45, 65, 50, 70], 'F': [65, 50, 70, 55, 75, 60, 80], 'C': [60, 45, 65, 50, 70, 55, 75] },
                chromaticMap: {}, intervalAbbreviations: {}
            };
            
            const noteLetters = ['C','D','E','F','G','A','B'];
            for(let octave = 1; octave <= 6; octave++){
                for(const letter of noteLetters) {
                    notesData.all.push(`${letter}bb/${octave}`, `${letter}b/${octave}`, `${letter}/${octave}`, `${letter}#/${octave}`, `${letter}##/${octave}`);
                }
            }
            notesData.all = notesData.all.filter(n => !n.startsWith('E##') && !n.startsWith('B##') && !n.startsWith('Fbb') && !n.startsWith('Cbb'));

            Object.keys(notesData.keySignatures).forEach((key, index) => {
                if (index < 8) { notesData.keySignatures[key].type = index === 0 ? null : 'sharp'; notesData.keySignatures[key].count = index; } 
                else { notesData.keySignatures[key].type = 'flat'; notesData.keySignatures[key].count = index - 7; }
            });
            notesData.natural = notesData.all.filter(n => !n.includes('#') && !n.includes('b'));
            const calculateDiatonic = (note) => { const parts = note.split('/'); const letter = parts[0][0]; const octave = parseInt(parts[1], 10); return octave * 7 + notesData.letterToDiatonic[letter]; };
            const generateY = (baseNote, baseY) => { const baseVal = calculateDiatonic(baseNote); const positions = {}; notesData.all.forEach(n => { positions[n] = baseY - (calculateDiatonic(n) - baseVal) * 5; }); return positions; };
            // --- FINAL CLEF POSITIONS ---
            notesData.clefs = { 'G': { symbol: '𝄞', symbolY: 68, yPositions: generateY('G/4', 70) }, 'F': { symbol: '𝄢', symbolY: 70, yPositions: generateY('F/3', 50) }, 'C': { symbol: '𝄡', symbolY: 70, yPositions: generateY('C/4', 60) } };
            
            const baseValues = {'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11};
            notesData.all.forEach(note => {
                const [name, octaveStr] = note.split('/');
                const octave = parseInt(octaveStr, 10);
                const letter = name[0];
                const accidentals = name.substring(1);
                
                let value = baseValues[letter];
                for (const char of accidentals) {
                    if (char === '#') value++;
                    else if (char === 'b') value--;
                }
                notesData.chromaticMap[note] = 12 * (octave + 1) + (value % 12);
            });
            notesData.intervalAbbreviations = { '1-0': '1', '2-1': 'b2', '2-2': '2', '3-3': 'b3', '3-4': '3', '4-5': '4', '4-6': '#4', '5-6': 'b5', '5-7': '5', '5-8': '#5', '6-8': 'b6', '6-9': '6', '7-10': 'b7', '7-11': '7', '8-12': '8', '9-13': 'b9', '9-14': '9', '10-15': 'b10', '10-16': '10', '11-17': '11', '11-18': '#11', '12-18': 'b12', '12-19': '12', '13-20': 'b13', '13-21': '13'};
        }
        
        function attachEventListeners() {
            ui.startStopButton.addEventListener('click', () => state.exerciseStarted ? stopExercise() : startExercise());
            ui.pauseResumeButton.addEventListener('click', togglePause);
            ui.showTutorialBtn.addEventListener('click', showTutorial);
            ui.closeModalBtn.addEventListener('click', hideTutorial);
            ui.tutorialModal.addEventListener('click', (e) => e.target === ui.tutorialModal && hideTutorial());
            ui.nextTutorialStepBtn.addEventListener('click', nextTutorialStep);
            ui.prevTutorialStepBtn.addEventListener('click', prevTutorialStep);

            let staveClickTimer = null;
            let staveClickCount = 0;
            ui.staveContainer.addEventListener('click', (e) => {
                staveClickCount++;
                if (staveClickTimer) {
                    clearTimeout(staveClickTimer);
                }
                staveClickTimer = setTimeout(() => {
                    if (staveClickCount === 1) {
                        if (!state.exerciseStarted) {
                            startExercise();
                        } else {
                            togglePause();
                        }
                    } else if (staveClickCount >= 2) {
                        if (state.exerciseStarted) {
                            stopExercise();
                        }
                    }
                    staveClickCount = 0;
                }, 300);
            });
            
            ui.showNoteNamesToggle.addEventListener('change', () => { 
                state.showNoteNames = ui.showNoteNamesToggle.checked; 
                updateHarmonyControlsVisibility();
                renderStave(); 
            });

            ui.showGuideToggle.addEventListener('change', () => {
                state.showGuide = ui.showGuideToggle.checked;
                if (!state.exerciseStarted) {
                    if (ui.guideLine) ui.guideLine.style.display = 'none';
                }
            });

            ui.cipherTypeSelect.addEventListener('change', (e) => {
                state.cipherType = e.target.value;
                renderStave();
            });

            ui.exerciseTypeRadios.forEach(radio => radio.addEventListener('change', (e) => {
                state.exerciseType = e.target.value;
                updateHarmonyControlsVisibility();
                if(state.exerciseStarted) stopExercise();
                renderStave();
            }));

            ui.notesPerChordSelect.addEventListener('change', (e) => { 
                state.notesPerChord = parseInt(e.target.value, 10);
                updateHarmonyControlsVisibility();
                if(state.exerciseStarted) stopExercise();
                renderStave(); 
            });

            ui.intervalSelect.addEventListener('change', e => { state.selectedInterval = parseInt(e.target.value, 10); if(state.exerciseStarted) stopExercise(); });
            ui.triadSelect.addEventListener('change', e => { state.selectedTriad = e.target.value; if(state.exerciseStarted) stopExercise(); });
            ui.triadPositionSelect.addEventListener('change', e => { state.triadPosition = e.target.value; if(state.exerciseStarted) stopExercise(); });
            ui.quadVoicingSelect.addEventListener('change', e => { state.selectedQuadVoicing = e.target.value; if(state.exerciseStarted) stopExercise(); });
            
            ui.melodyNoteNameStyleSelect.addEventListener('change', (e) => {
                state.melodyNoteNameStyle = e.target.value;
                if(state.exerciseStarted) renderStave();
            });

            ui.measuresSelect.addEventListener('change', handleMeasuresChange);
            ui.customMeasuresInput.addEventListener('input', handleMeasuresChange);
            
            ui.difficultySelect.addEventListener('change', () => {
                updateHarmonyControlsVisibility();
                updateDropVoicingOptions();
                if (state.exerciseStarted) stopExercise();
                renderStave();
            });

            [ui.clefSelect, ui.timeSigSelect, ui.changeBeatSelect, ui.keySigSelect].forEach(el => {
                el.addEventListener('change', () => {
                    if (state.exerciseStarted) stopExercise();
                    if (el === ui.timeSigSelect) updateChangeBeatOptions();
                    if (el === ui.keySigSelect) state.keySignature = ui.keySigSelect.value;
                    state.measuresChangeBeat = parseInt(ui.changeBeatSelect.value, 10);
                    renderStave();
                });
            });

            // --- Fullscreen Logic ---
            ui.fullscreenToggle.addEventListener('click', toggleFullscreen);

            function updateFullscreenIcons() {
                const isFullscreen = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
                ui.enterFullscreenIcon.classList.toggle('hidden', isFullscreen);
                ui.exitFullscreenIcon.classList.toggle('hidden', !isFullscreen);
                setTimeout(renderStave, 50);
            }

            ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'MSFullscreenChange'].forEach(event => {
                document.addEventListener(event, updateFullscreenIcons);
            });

            window.addEventListener('resize', () => {
                if(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                    clearTimeout(window.resizeTimeout);
                    window.resizeTimeout = setTimeout(renderStave, 100);
                }
            });

            window.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
                
                const key = e.key.toLowerCase();

                if (key === 'f') {
                    e.preventDefault();
                    toggleFullscreen();
                } else if (key === ' ') {
                    e.preventDefault();
                    state.spacebarPressCount++;
                    if (state.spacebarTimeout) {
                        clearTimeout(state.spacebarTimeout);
                    }
                    state.spacebarTimeout = setTimeout(() => {
                        if (state.spacebarPressCount === 1) {
                            if (!state.exerciseStarted) startExercise();
                            else togglePause();
                        } else if (state.spacebarPressCount >= 2) {
                            if (state.exerciseStarted) stopExercise();
                        }
                        state.spacebarPressCount = 0;
                    }, 300);
                } else if (key === 'n') {
                    e.preventDefault();
                    ui.showNoteNamesToggle.checked = !ui.showNoteNamesToggle.checked;
                    ui.showNoteNamesToggle.dispatchEvent(new Event('change'));
                } else if (key === 'g') {
                    e.preventDefault();
                    ui.showGuideToggle.checked = !ui.showGuideToggle.checked;
                    ui.showGuideToggle.dispatchEvent(new Event('change'));
                } else if (key === 'c') {
                    e.preventDefault();
                    const clefs = Array.from(ui.clefSelect.options).filter(opt => !opt.hidden);
                    const currentIndex = clefs.findIndex(opt => opt.value === ui.clefSelect.value);
                    const nextIndex = (currentIndex + 1) % clefs.length;
                    ui.clefSelect.value = clefs[nextIndex].value;
                    ui.clefSelect.dispatchEvent(new Event('change'));
                }
            });
        }

        function toggleFullscreen() {
            const el = ui.staveViewer;
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
                const requestFullscreen = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen || el.msRequestFullscreen;
                if (requestFullscreen) {
                    requestFullscreen.call(el).catch(err => {
                        console.warn(`Error al intentar activar la pantalla completa: ${err.message}`);
                    });
                }
            } else {
                const exitFullscreen = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen || document.msExitFullscreen;
                if (exitFullscreen) {
                    exitFullscreen.call(document).catch(err => {
                         console.warn(`Error al intentar salir de la pantalla completa: ${err.message}`);
                    });
                }
            }
        }
        
        function updateHarmonyControlsVisibility() {
            const isHarmony = state.exerciseType === 'armonia';
            const notes = parseInt(ui.notesPerChordSelect.value, 10);
            const showNames = ui.showNoteNamesToggle.checked;
            const difficulty = ui.difficultySelect.value;

            // Hide key signature for all harmony exercises and default to C major.
            ui.keySigContainer.classList.toggle('hidden', isHarmony);
            if (isHarmony) {
                state.keySignature = 'C';
                ui.keySigSelect.value = 'C'; // Ensure dropdown is also set for consistency
            } else {
                // When switching back to melody, read the current selection from the UI
                state.keySignature = ui.keySigSelect.value;
            }

            ui.harmonyOptionsContainer.classList.toggle('hidden', !isHarmony);
            ui.intervalOptionsContainer.classList.toggle('hidden', !isHarmony || notes !== 2);
            ui.triadOptionsContainer.classList.toggle('hidden', !isHarmony || notes !== 3);
            
            const showTriadPosition = isHarmony && notes === 3 && (difficulty === 'medium' || difficulty === 'advanced');
            ui.triadPositionContainer.classList.toggle('hidden', !showTriadPosition);

            ui.quadOptionsContainer.classList.toggle('hidden', !isHarmony || notes !== 4);
            
            const showMelodyNameOptions = !isHarmony && showNames;
            ui.melodyNoteNameOptionsContainer.classList.toggle('hidden', !showMelodyNameOptions);

            const showCipherControl = isHarmony && showNames && notes > 2;
            ui.cipherTypeContainer.classList.toggle('hidden', !showCipherControl);

            if (showCipherControl) {
                const select = ui.cipherTypeSelect;
                const currentVal = select.value;
                select.innerHTML = '';
                let options = [];
                if (notes === 3) {
                    options = [
                        {value: 'todos', text: 'Todos'},
                        {value: 'americano', text: 'Americano'},
                        {value: 'bajo', text: 'Bajo Cifrado'}
                    ];
                } else if (notes === 4) {
                    options = [
                        {value: 'todos', text: 'Todos'},
                        {value: 'americano', text: 'Americano'},
                        {value: 'drops', text: 'Drops'}
                    ];
                }
                options.forEach(opt => {
                    const optionEl = document.createElement('option');
                    optionEl.value = opt.value;
                    optionEl.textContent = opt.text;
                    select.appendChild(optionEl);
                });
                
                if (options.some(opt => opt.value === currentVal)) {
                    select.value = currentVal;
                } else {
                    select.value = 'todos';
                }
                state.cipherType = select.value;
            }

            const isQuad = isHarmony && notes === 4;
            const is3or4VoiceHarmony = isHarmony && (notes === 3 || notes === 4);

            ui.timeSigContainer.classList.toggle('hidden', isQuad);
            if(isQuad) {
                ui.timeSigSelect.value = '4/4';
                state.timeSignatureBeats = 4;
                updateChangeBeatOptions();
            }

            const clefOptions = ui.clefSelect.options;
            for (let i = 0; i < clefOptions.length; i++) {
                const option = clefOptions[i];
                if (option.value === 'F' || option.value === 'C') {
                    option.hidden = is3or4VoiceHarmony;
                }
            }
            if (is3or4VoiceHarmony && ui.clefSelect.value !== 'G') {
                ui.clefSelect.value = 'G';
            }

            const basicOption = ui.difficultySelect.querySelector('option[value="basico"]');
            if (basicOption) basicOption.disabled = isQuad;
            
            if (isQuad && ui.difficultySelect.value === 'basico') {
                ui.difficultySelect.value = 'medium';
                ui.difficultySelect.dispatchEvent(new Event('change'));
            }
        }
        function updateDropVoicingOptions() {
            const voicings = notesData.voicingsByDifficulty.advanced;
            if (!voicings) {
                ui.quadVoicingSelect.innerHTML = '';
                return;
            }

            const currentVoicing = ui.quadVoicingSelect.value;
            ui.quadVoicingSelect.innerHTML = '';
            let newSelectionAvailable = false;
            
            for (const key in voicings) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = voicings[key];
                ui.quadVoicingSelect.appendChild(option);
                if (key === currentVoicing) newSelectionAvailable = true;
            }
            
            if (newSelectionAvailable) {
                ui.quadVoicingSelect.value = currentVoicing;
            } else {
                 // Default to 'all' if it exists for the new level, otherwise first option
                if(voicings['all']) ui.quadVoicingSelect.value = 'all';
                else ui.quadVoicingSelect.selectedIndex = 0;
            }
        }

        function handleMeasuresChange() {
            if (ui.measuresSelect.value === 'custom') {
                ui.customMeasuresContainer.classList.remove('hidden');
                const customValue = parseInt(ui.customMeasuresInput.value, 10);
                state.measuresPerExercise = isNaN(customValue) || customValue <= 0 ? 1 : customValue;
            } else {
                ui.customMeasuresContainer.classList.add('hidden');
                state.measuresPerExercise = parseInt(ui.measuresSelect.value, 10);
            }
            ui.measuresCount.textContent = `0 / ${state.measuresPerExercise}`;
        }
        function updateChangeBeatOptions() {
            const timeSigParts = ui.timeSigSelect.value.split('/');
            state.timeSignatureBeats = parseInt(timeSigParts[0], 10);
            ui.changeBeatSelect.innerHTML = '';
            for (let i = 1; i <= state.timeSignatureBeats; i++) {
                const option = document.createElement('option');
                option.value = i; option.textContent = i;
                ui.changeBeatSelect.appendChild(option);
            }
            ui.changeBeatSelect.value = state.timeSignatureBeats;
            state.measuresChangeBeat = state.timeSignatureBeats;
        }
        async function startExercise() {
            try {
                if (!audio.context) audio.context = new (window.AudioContext || window.webkitAudioContext)();
                if (audio.context.state === 'suspended') await audio.context.resume();
                handleMeasuresChange();
                state.exerciseMeasures = generateExercise();
                if (state.exerciseMeasures.length === 0) { console.error("Failed to generate measures."); stopExercise(); return; }
                Object.assign(state, { exerciseStarted: true, isPlaying: true, isPaused: false, isPreRoll: true, currentMetronomeCount: 0 });
                ui.preRollMessage.classList.remove('hidden');
                ui.displayArea.classList.add('hidden');
                ui.startStopButton.textContent = 'Detener';
                ui.pauseResumeButton.textContent = 'Pausar';
                ui.pauseResumeButton.classList.remove('hidden');
                audio.nextNoteTime = audio.context.currentTime + 0.5;
                scheduler();
                renderStave();
            } catch (e) { console.error("Error starting exercise:", e); stopExercise(); }
        }
        function stopExercise() {
            Object.assign(state, { exerciseStarted: false, isPlaying: false, isPaused: false, isPreRoll: false, currentMeasureIndex: -1, currentMetronomeCount: 0, currentMeasureContent: [] });
            ui.startStopButton.textContent = 'Comenzar';
            ui.pauseResumeButton.classList.add('hidden');
            ui.displayArea.classList.add('hidden');
            if (state.metronomeTimer) { clearTimeout(state.metronomeTimer); state.metronomeTimer = null; }
            handleMeasuresChange();
            ui.metronomeCount.textContent = "0";
            ui.preRollMessage.classList.add('hidden');
            if(ui.guideLine) ui.guideLine.style.display = 'none';
            renderStave();
        }
        function togglePause() {
            if (!state.exerciseStarted) return;
            state.isPaused = !state.isPaused;
            if (state.isPaused) {
                clearTimeout(state.metronomeTimer);
                audio.pauseStartTime = audio.context.currentTime;
                ui.pauseResumeButton.textContent = 'Reanudar';
            } else {
                const elapsedPauseTime = audio.context.currentTime - audio.pauseStartTime;
                audio.nextNoteTime += elapsedPauseTime;
                ui.pauseResumeButton.textContent = 'Pausar';
                scheduler();
            }
        }
        function scheduler() {
            if (!state.isPlaying || state.isPaused) return;
            while (audio.nextNoteTime < audio.context.currentTime + audio.scheduleAheadTime) {
                const tempo = parseInt(ui.tempoInput.value, 10);
                const beatDuration = 60.0 / tempo;
                state.currentMetronomeCount++;
                if (state.currentMetronomeCount > state.timeSignatureBeats) state.currentMetronomeCount = 1;
                playMetronomeSound(audio.nextNoteTime, state.currentMetronomeCount === 1);
                if (state.isPreRoll) {
                    ui.preRollCount.textContent = state.currentMetronomeCount;
                    if (state.currentMetronomeCount === state.timeSignatureBeats) {
                        state.isPreRoll = false;
                        ui.preRollMessage.classList.add('hidden');
                        ui.displayArea.classList.remove('hidden');
                        state.currentMeasureIndex = 0;
                        state.currentMeasureContent = state.exerciseMeasures[0];
                        ui.measuresCount.textContent = `1 / ${state.measuresPerExercise}`;
                    }
                } else {
                    if (state.currentMetronomeCount === state.measuresChangeBeat) {
                        state.currentMeasureIndex++;
                        if (state.currentMeasureIndex < state.measuresPerExercise) {
                            state.currentMeasureContent = state.exerciseMeasures[state.currentMeasureIndex];
                            ui.measuresCount.textContent = `${state.currentMeasureIndex + 1} / ${state.measuresPerExercise}`;
                        } else { stopExercise(); return; }
                    }
                    ui.metronomeCount.textContent = state.currentMetronomeCount;
                }
                renderStave();
                updateGuidePosition();
                audio.nextNoteTime += beatDuration;
            }
            state.metronomeTimer = setTimeout(scheduler, audio.lookahead);
        }
        function updateGuidePosition() {
            if (!state.showGuide || !state.exerciseStarted || state.isPreRoll) {
                if (ui.guideLine) ui.guideLine.style.display = 'none';
                return;
            }
            if (ui.guideLine) {
                ui.guideLine.style.display = 'block';
                let beatIndex = state.currentMetronomeCount - 1;
                
                if (state.exerciseType === 'armonia' && state.notesPerChord === 4) {
                    beatIndex = Math.floor(beatIndex / 2);
                }

                const xPos = state.noteStartX + (beatIndex * state.noteSpacing);
                if (!isNaN(xPos)) {
                    ui.guideLine.setAttribute('x1', xPos);
                    ui.guideLine.setAttribute('x2', xPos);
                }
            }
        }
        function getNoteRangeForDifficulty() {
            const { natural } = notesData;
            switch (ui.difficultySelect.value) {
                case 'basico': 
                    if (ui.clefSelect.value === 'G') return notesData.all.slice(notesData.all.indexOf('E/4'), notesData.all.indexOf('F/5') + 1);
                    if (ui.clefSelect.value === 'F') return notesData.all.slice(notesData.all.indexOf('G/2'), notesData.all.indexOf('A/3') + 1);
                    return notesData.all.slice(notesData.all.indexOf('F/3'), notesData.all.indexOf('G/4') + 1); // C Clef
                case 'medium':
                    if (ui.clefSelect.value === 'G') return notesData.all.slice(notesData.all.indexOf('E/3'), notesData.all.indexOf('A/5') + 1);
                    if (ui.clefSelect.value === 'F') return notesData.all.slice(notesData.all.indexOf('E/2'), notesData.all.indexOf('C/4') + 1);
                    return notesData.all.slice(notesData.all.indexOf('D/2'), notesData.all.indexOf('B/4') + 1); // C Clef
                default: // 'advanced'
                    if (ui.clefSelect.value === 'G') return notesData.all.slice(notesData.all.indexOf('E/3'), notesData.all.indexOf('E/6') + 1);
                    if (ui.clefSelect.value === 'F') return notesData.all.slice(notesData.all.indexOf('C/2'), notesData.all.indexOf('F/4') + 1);
                    return notesData.all.slice(notesData.all.indexOf('B/1'), notesData.all.indexOf('B/4') + 1); // C Clef
            }
        }
        function generateExercise() {
            const difficultyBoundaries = getNoteRangeForDifficulty();
            const noteRange = notesData.all.slice(
                notesData.all.indexOf(difficultyBoundaries[0]),
                notesData.all.indexOf(difficultyBoundaries[difficultyBoundaries.length - 1]) + 1
            );
            
            const diatonicScale = notesData.keySignatures[state.keySignature].notes;
            const fullDiatonicPool = [];
            for (let octave = 1; octave < 7; octave++) {
                for (const noteName of diatonicScale) {
                    const noteWithOctave = `${noteName}/${octave}`;
                    if (notesData.all.includes(noteWithOctave)) fullDiatonicPool.push(noteWithOctave);
                }
            }
            const diatonicNotePool = fullDiatonicPool.filter(note => noteRange.includes(note));

            if (!diatonicNotePool || diatonicNotePool.length < 2) { console.error("Diatonic note pool too small.", diatonicNotePool); return []; } 
            
            const allMeasures = [];
            let lastNote = diatonicNotePool[Math.floor(Math.random() * diatonicNotePool.length)];
            
            for (let i = 0; i < state.measuresPerExercise; i++) {
                let rootNotesPool = (state.exerciseType === 'armonia' && state.notesPerChord === 4) ? noteRange : diatonicNotePool;
                let firstNoteInMeasure = (i === 0) ? lastNote : getNextMeasureStartNote(lastNote, rootNotesPool);
                let rootNotesForMeasure = [firstNoteInMeasure];
                
                const maxInterval = (ui.difficultySelect.value === 'advanced') ? 7 : 5;
                const poolForMelody = (state.exerciseType === 'armonia' && state.notesPerChord === 4) ? noteRange : rootNotesPool;
                const firstNoteIndex = poolForMelody.indexOf(firstNoteInMeasure);

                const measureNotePool = (firstNoteIndex !== -1) ? poolForMelody.slice(
                    Math.max(0, firstNoteIndex - maxInterval),
                    Math.min(poolForMelody.length - 1, firstNoteIndex + maxInterval) + 1
                ).filter(n => rootNotesPool.includes(n)) : rootNotesPool;
                
                let notesPerMeasure = state.timeSignatureBeats;
                if (state.exerciseType === 'armonia' && state.notesPerChord === 4) {
                    notesPerMeasure = 2;
                }

                for (let b = 1; b < notesPerMeasure; b++) {
                    const nextRoot = getNextMelodicNote(rootNotesForMeasure, measureNotePool.length > 1 ? measureNotePool : rootNotesPool);
                    rootNotesForMeasure.push(nextRoot);
                }

                if (state.exerciseType === 'melodia') {
                    allMeasures.push(rootNotesForMeasure);
                } else {
                    const measureChords = rootNotesForMeasure.map(root => generateHarmonicItem(root, noteRange, fullDiatonicPool)).filter(Boolean);
                    if (measureChords.length === notesPerMeasure) {
                        allMeasures.push(measureChords);
                    } else { i--; continue; }
                }

                if(allMeasures.length > i && allMeasures[i] && allMeasures[i].length > 0) {
                     const lastItem = allMeasures[i][allMeasures[i].length - 1];
                     lastNote = Array.isArray(lastItem) ? lastItem.sort((a,b) => notesData.all.indexOf(a) - notesData.all.indexOf(b))[0] : lastItem;
                }
            }
            return allMeasures;
        }
        function getNextMeasureStartNote(previousNote, notePool) {
            const lastNoteIndex = notePool.indexOf(previousNote);
            if (lastNoteIndex === -1) return notePool[Math.floor(Math.random() * notePool.length)];
            const maxLeap = (ui.difficultySelect.value === 'advanced') ? 7 : 4; 
            let possibleNotes = [];
            for (let leap = 3; leap <= maxLeap; leap++) {
                if (lastNoteIndex + leap < notePool.length) possibleNotes.push(notePool[lastNoteIndex + leap]);
                if (lastNoteIndex - leap >= 0) possibleNotes.push(notePool[lastNoteIndex - leap]);
            }
            return possibleNotes.length > 0 ? possibleNotes[Math.floor(Math.random() * possibleNotes.length)] : previousNote;
        }
        function getNextMelodicNote(currentNotes, notePool) {
            const previousNote = currentNotes[currentNotes.length - 1];
            const prevNoteIndex = notePool.indexOf(previousNote);
            if (prevNoteIndex === -1) return notePool[Math.floor(Math.random() * notePool.length)];
            let direction = 0;
            if (currentNotes.length > 1) {
                const lastNoteIndex = notePool.indexOf(currentNotes[currentNotes.length - 2]);
                if(lastNoteIndex !== -1) {
                    const lastInterval = prevNoteIndex - lastNoteIndex;
                    if (Math.abs(lastInterval) >= 3) direction = lastInterval > 0 ? -1 : 1;
                }
            }
            let candidates;
            if (direction !== 0) {
                 candidates = notePool.filter((n, idx) => {
                    const interval = idx - prevNoteIndex;
                    return (direction === 1 && interval > 0 && interval <= 2) || (direction === -1 && interval < 0 && interval >= -2);
                });
            } else {
                candidates = notePool.filter((n, idx) => Math.abs(idx - prevNoteIndex) <= 2 && n !== previousNote);
            }
            if (candidates.length === 0) candidates = notePool.filter(n => n !== previousNote);
            if (candidates.length === 0) return previousNote;
            return candidates[Math.floor(Math.random() * candidates.length)];
        }
        function alterNote(note, semitones, keySignature) {
            const chromaticValue = notesData.chromaticMap[note];
            if (chromaticValue === undefined) {
                console.warn(`Cannot alter note, not found in chromatic map: ${note}`);
                return null;
            }
            
            const newChromaticValue = chromaticValue + semitones;
            
            const keyInfo = notesData.keySignatures[keySignature];
            let preferredAccidental = '#'; // Default for C major and sharp keys
            if (keyInfo && keyInfo.type === 'flat') {
                preferredAccidental = 'b';
            }

            return getNoteNameFromChromaticValue(newChromaticValue, preferredAccidental);
        }
        
        function getNoteNameFromChromaticValue(chromaticValue, preferredAccidental = '#') {
            const noteIndex = chromaticValue % 12;
            const octave = Math.floor(chromaticValue / 12) - 1;

            if (octave < 1 || octave > 6) { 
                return null;
            }

            let noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            let flatNoteNames = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

            let noteName;

            if (noteNames[noteIndex] !== flatNoteNames[noteIndex]) {
                 if (preferredAccidental === 'b') {
                    noteName = flatNoteNames[noteIndex];
                 } else { 
                    noteName = noteNames[noteIndex];
                 }
            } else {
                noteName = noteNames[noteIndex];
            }
            
            const result = `${noteName}/${octave}`;
            
            if(notesData.all.includes(result)) {
                return result;
            } else {
                 if(noteNames[noteIndex] !== flatNoteNames[noteIndex]) {
                     const fallbackNoteName = (noteName === noteNames[noteIndex]) ? flatNoteNames[noteIndex] : noteNames[noteIndex];
                     const fallbackResult = `${fallbackNoteName}/${octave}`;
                     if(notesData.all.includes(fallbackResult)){
                         return fallbackResult;
                     }
                 }
            }
            
            return null; 
        }

        function generateHarmonicItem(rootNote, noteRange, fullDiatonicPool) {
            let item = null;
            let attempts = 0;
            const numNotes = state.notesPerChord;

            while (item === null && attempts < 50) {
                attempts++;
                const currentRoot = attempts > 1 ? (numNotes === 4 ? noteRange : fullDiatonicPool)[Math.floor(Math.random() * (numNotes === 4 ? noteRange.length : fullDiatonicPool.length))] : rootNote;
                if (!currentRoot) continue;
                
                let finalNotes = [];

                if (numNotes === 2) {
                    const rootIndex = fullDiatonicPool.indexOf(currentRoot);
                    if (rootIndex === -1) continue;
                    let intervalSteps = state.selectedInterval;
                    if (intervalSteps === 0) {
                        const difficulty = ui.difficultySelect.value;
                        const maxDiatonicStep = (difficulty === 'basico') ? 7 : 12;
                        intervalSteps = Math.floor(Math.random() * maxDiatonicStep) + 1;
                    }
                    const topNoteIndex = rootIndex + intervalSteps;
                    if (topNoteIndex < fullDiatonicPool.length) {
                        finalNotes = [currentRoot, fullDiatonicPool[topNoteIndex]];
                    }
                } else if (numNotes === 3) {
                    const rootIndex = fullDiatonicPool.indexOf(currentRoot);
                    if (rootIndex === -1 || rootIndex + 4 >= fullDiatonicPool.length) continue;

                    let chordFamily = state.selectedTriad;
                    if (chordFamily === 'all') {
                        const types = ['triad', 'sus2', 'sus4'];
                        chordFamily = types[Math.floor(Math.random() * types.length)];
                    } else {
                        if (chordFamily.includes('triad')) chordFamily = 'triad';
                        if (chordFamily.includes('sus2')) chordFamily = 'sus2';
                        if (chordFamily.includes('sus4')) chordFamily = 'sus4';
                    }

                    let fundamentalClosedChord;
                    if (chordFamily === 'triad') {
                        fundamentalClosedChord = [currentRoot, fullDiatonicPool[rootIndex + 2], fullDiatonicPool[rootIndex + 4]];
                    } else if (chordFamily === 'sus2') {
                        fundamentalClosedChord = [currentRoot, fullDiatonicPool[rootIndex + 1], fullDiatonicPool[rootIndex + 4]];
                    } else { // sus4
                        fundamentalClosedChord = [currentRoot, fullDiatonicPool[rootIndex + 3], fullDiatonicPool[rootIndex + 4]];
                    }

                    let closedChord = [...fundamentalClosedChord];
                    if (chordFamily === 'triad') {
                        let inversionType = state.selectedTriad;
                        if (inversionType === 'all' || !inversionType.includes('inv')) {
                            const invTypes = ['triad_fundamental', 'triad_inv1', 'triad_inv2'];
                            inversionType = invTypes[Math.floor(Math.random() * invTypes.length)];
                        }
                        if (inversionType === 'triad_inv1') {
                             const newRoot = alterNote(closedChord[0], 12, state.keySignature);
                             if (!newRoot) continue;
                             closedChord = [closedChord[1], closedChord[2], newRoot];
                        } else if (inversionType === 'triad_inv2') {
                             const newRoot = alterNote(closedChord[0], 12, state.keySignature);
                             const newThird = alterNote(closedChord[1], 12, state.keySignature);
                             if (!newRoot || !newThird) continue;
                             closedChord = [closedChord[2], newRoot, newThird];
                        }
                    }
                    closedChord.sort((a, b) => notesData.chromaticMap[a] - notesData.chromaticMap[b]);
                    
                    finalNotes = [...closedChord];

                    const difficulty = ui.difficultySelect.value;
                    const isBasicDifficulty = difficulty === 'basico';
                    const targetPosition = isBasicDifficulty ? 'cerrada' : (state.triadPosition === 'all' ? (Math.random() < 0.5 ? 'cerrada' : 'abierta') : state.triadPosition);
                    
                    if (targetPosition === 'abierta') {
                        const middleNoteDown = alterNote(finalNotes[1], -12, state.keySignature);
                        if(middleNoteDown) {
                            finalNotes[1] = middleNoteDown;
                        } else { 
                            continue; 
                        }
                    }

                } else if (numNotes === 4) {
                    const rootName = currentRoot.split('/')[0];
                    const possibleChords = notesData.allowedFourNoteChords[rootName];
                    if (!possibleChords || possibleChords.length === 0) continue; 
                    
                    const chosenChordData = possibleChords[Math.floor(Math.random() * possibleChords.length)];
                    const chordNoteNames = chosenChordData.notes;
                    
                    let closePositionNotes = [];
                    let lastChromaticValue = -1;
                    const rootOctave = parseInt(currentRoot.split('/')[1], 10);
                    
                    let tempNotes = [];
                    for(let i = 0; i < chordNoteNames.length; i++) {
                        const noteName = chordNoteNames[i];
                        let found = false;
                        for(let oct = rootOctave - 1; oct <= rootOctave + 1; oct++) {
                            const fullNote = `${noteName}/${oct}`;
                            if(notesData.chromaticMap[fullNote] !== undefined) {
                                tempNotes.push(fullNote);
                                found = true;
                                break;
                            }
                        }
                        if(!found) { tempNotes = []; break; }
                    }

                    if(tempNotes.length < 4) continue;
                    
                    tempNotes.sort((a, b) => notesData.chromaticMap[a] - notesData.chromaticMap[b]);

                    // Find the most compact voicing around the root note
                    let minRange = Infinity;
                    for (let i = 0; i <= tempNotes.length - 4; i++) {
                        let potentialVoicing = tempNotes.slice(i, i + 4);
                        let currentRange = notesData.chromaticMap[potentialVoicing[3]] - notesData.chromaticMap[potentialVoicing[0]];
                        if(currentRange < minRange) {
                            minRange = currentRange;
                            closePositionNotes = potentialVoicing;
                        }
                    }
                    
                    if (closePositionNotes.length < 4) continue;
                    
                    let voicing = ui.quadVoicingSelect.value;
                    if(voicing === 'all'){
                        const allVoicings = Object.keys(notesData.voicingAbbreviations).filter(v => v !== 'all' && v !== '');
                        voicing = allVoicings[Math.floor(Math.random() * allVoicings.length)];
                    }
                    
                    // Inversions are implicitly handled by the user list, so we just apply drops
                    finalNotes = [...closePositionNotes];
                    const dropNote = (note, octavesDown) => alterNote(note, -12 * octavesDown, state.keySignature);
                    
                    try {
                        if (voicing === 'drop2') finalNotes.unshift(dropNote(finalNotes.splice(2, 1)[0], 1));
                        else if (voicing === 'drop3') finalNotes.unshift(dropNote(finalNotes.splice(1, 1)[0], 1));
                        else if (voicing === 'drop24') {
                            let note2 = dropNote(finalNotes.splice(2, 1)[0], 1); let note4 = dropNote(finalNotes.splice(0, 1)[0], 1);
                            finalNotes.unshift(note2, note4);
                        } else if (voicing === 'drop23') {
                            let note2 = dropNote(finalNotes.splice(2, 1)[0], 1); let note3 = dropNote(finalNotes.splice(1, 1)[0], 1);
                            finalNotes.unshift(note2, note3);
                        } else if (voicing === 'doubleDrop23') {
                            let note2 = dropNote(finalNotes.splice(2, 1)[0], 2); let note3 = dropNote(finalNotes.splice(1, 1)[0], 1);
                            finalNotes.unshift(note2, note3);
                        }
                    } catch (e) { finalNotes = []; } 
                    finalNotes = finalNotes.filter(Boolean);
                    if(finalNotes.length === 4) finalNotes.voicing = voicing;
                }
                
                if (finalNotes.length !== numNotes || finalNotes.some(n => n === null)) continue;
                finalNotes.sort((a, b) => notesData.chromaticMap[a] - notesData.chromaticMap[b]);
                if (!finalNotes.every(n => noteRange.includes(n))) continue;

                const clef = ui.clefSelect.value;
                const lowestNoteValue = notesData.chromaticMap[finalNotes[0]];
                let minNoteValue = -1;
                if (clef === 'G') { minNoteValue = notesData.chromaticMap['E/3']; }
                if (minNoteValue !== -1 && lowestNoteValue < minNoteValue) continue;

                item = finalNotes;
            }
            return item;
        }

        function playMetronomeSound(time, isAccent) {
            if (!audio.context) return;
            const osc = audio.context.createOscillator(); const gain = audio.context.createGain();
            osc.connect(gain); gain.connect(audio.context.destination);
            osc.frequency.value = isAccent ? 880 : 440; osc.type = 'square';
            gain.gain.setValueAtTime(isAccent ? 0.3 : 0.2, time);
            osc.start(time); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05); osc.stop(time + 0.1);
        }
        
        function getIntervalAbbreviation(notes) {
            if (notes.length !== 2) return { name: '' };
            const [note1, note2] = notes.sort((a,b) => notesData.chromaticMap[a] - notesData.chromaticMap[b]);

            const [name1, oct1_str] = note1.split('/'); const [name2, oct2_str] = note2.split('/');
            const oct1 = parseInt(oct1_str, 10); const oct2 = parseInt(oct2_str, 10);
            const diatonicIndex1 = notesData.letterToDiatonic[name1[0]]; const diatonicIndex2 = notesData.letterToDiatonic[name2[0]];

            const diatonicDiff = (oct2 - oct1) * 7 + (diatonicIndex2 - diatonicIndex1) + 1;
            const chromaticDiff = notesData.chromaticMap[note2] - notesData.chromaticMap[note1];
            const key = `${diatonicDiff}-${chromaticDiff}`;
            
            let abbrev = notesData.intervalAbbreviations[key] || diatonicDiff.toString();

            return { name: abbrev };
        }

        function getDiatonicInterval(note1, note2) {
            if (notesData.chromaticMap[note1] > notesData.chromaticMap[note2]) {
                [note1, note2] = [note2, note1];
            }
            const [name1, oct1_str] = note1.split('/');
            const [name2, oct2_str] = note2.split('/');
            const oct1 = parseInt(oct1_str, 10);
            const oct2 = parseInt(oct2_str, 10);
            const diatonicIndex1 = notesData.letterToDiatonic[name1[0]];
            const diatonicIndex2 = notesData.letterToDiatonic[name2[0]];
            return (oct2 - oct1) * 7 + (diatonicIndex2 - diatonicIndex1) + 1;
        }
        
        function getChordName(notes) {
            const sortedNotes = [...notes].sort((a, b) => notesData.chromaticMap[a] - notesData.chromaticMap[b]);
            const bassNote = sortedNotes[0];
            const bassNoteName = bassNote.split('/')[0];
            
            for (let i = 0; i < sortedNotes.length; i++) {
                const potentialRoot = sortedNotes[i];
                const rootValue = notesData.chromaticMap[potentialRoot];
                const intervals = sortedNotes.map(n => (notesData.chromaticMap[n] - rootValue + 120) % 12).sort((a,b) => a - b);
                
                let quality = null;
                const intervalString = intervals.join(',');
                let rootNoteName = potentialRoot.split('/')[0];

                if (notes.length === 3) {
                    if (intervalString === '0,4,7') quality = ''; 
                    else if (intervalString === '0,3,7') quality = 'm';
                    else if (intervalString === '0,3,6') quality = '°'; 
                    else if (intervalString === '0,4,8') quality = '+';
                    else if (intervalString === '0,2,7') quality = 'sus2'; 
                    else if (intervalString === '0,5,7') quality = 'sus4';
                } else if (notes.length === 4) {
                    if (intervalString === '0,4,7,11') quality = 'maj7'; 
                    else if (intervalString === '0,3,7,10') quality = 'm7';
                    else if (intervalString === '0,4,7,10') quality = '7'; 
                    else if (intervalString === '0,3,6,10') quality = 'm7♭5';
                    else if (intervalString === '0,3,6,9') quality = '°7';
                }

                if (quality !== null) {
                    if (rootNoteName !== bassNoteName) { 
                        const rootLetter = rootNoteName.slice(0, 1);
                        const bassLetter = bassNoteName.slice(0, 1);
                        if (rootLetter === bassLetter) {
                            const enarmonicMap = { 'C#': 'Db', 'Db': 'C#', 'D#': 'Eb', 'Eb': 'D#', 'F#': 'Gb', 'Gb': 'F#', 'G#': 'Ab', 'Ab': 'G#', 'A#': 'Bb', 'Bb': 'A#' };
                            const newRootName = enarmonicMap[rootNoteName];
                            if (newRootName) rootNoteName = newRootName;
                        }
                    }
                    
                    let chordName = rootNoteName === bassNoteName ? `${rootNoteName}${quality}` : `${rootNoteName}${quality}/${bassNoteName}`;
                    
                    let figuredBass = [];
                    const isStandardTriad = (quality === '' || quality === 'm' || quality === '°' || quality === '+');
                    const isStandardSeventh = (quality === 'maj7' || quality === 'm7' || quality === '7' || quality === 'm7♭5' || quality === '°7');

                    if (notes.length === 3 && isStandardTriad) {
                        const interval1 = getDiatonicInterval(bassNote, sortedNotes[1]);
                        const interval2 = getDiatonicInterval(bassNote, sortedNotes[2]);
                        
                        // Notación estándar del bajo cifrado para tríadas
                        if (interval1 === 3 && interval2 === 5) figuredBass = []; // Posición fundamental 5/3 (se omite)
                        else if (interval1 === 3 && interval2 === 6) figuredBass = ['6']; // 1ra inversión 6/3
                        else if (interval1 === 4 && interval2 === 6) figuredBass = ['6', '4']; // 2da inversión 6/4
                    } else if (notes.length === 4 && isStandardSeventh) {
                        const interval1 = getDiatonicInterval(bassNote, sortedNotes[1]);
                        const interval2 = getDiatonicInterval(bassNote, sortedNotes[2]);
                        const interval3 = getDiatonicInterval(bassNote, sortedNotes[3]);

                        // Notación estándar del bajo cifrado para acordes de séptima
                        if (interval1 === 3 && interval2 === 5 && interval3 === 7) figuredBass = ['7']; // Posición fundamental
                        else if (interval1 === 3 && interval2 === 5 && interval3 === 6) figuredBass = ['6', '5']; // 1ra inversión
                        else if (interval1 === 3 && interval2 === 4 && interval3 === 6) figuredBass = ['4', '3']; // 2da inversión
                        else if (interval1 === 2 && interval2 === 4 && interval3 === 6) figuredBass = ['4', '2']; // 3ra inversión
                    }

                    return { name: chordName, figuredBass: figuredBass };
                }
            }
            return { name: '', figuredBass: [] };
        }

        function renderStave() {
            ui.staveContainer.innerHTML = '';
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            
            svg.setAttribute('viewBox', `0 0 420 210`);
            
            ui.staveContainer.appendChild(svg);

            const guideLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            guideLine.setAttribute('id', 'guide-line');
            guideLine.setAttribute('y1', '25'); 
            guideLine.setAttribute('y2', '125'); 
            guideLine.setAttribute('stroke', 'rgba(239, 68, 68, 0.7)');
            guideLine.setAttribute('stroke-width', '2');
            guideLine.setAttribute('stroke-linecap', 'round');
            guideLine.style.display = 'none';
            guideLine.style.transition = 'transform 0.1s linear';
            svg.appendChild(guideLine);
            ui.guideLine = guideLine;

            const mainGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
            mainGroup.setAttribute('transform', 'translate(0, 40)');
            svg.appendChild(mainGroup);

            let contentToDraw = [];
            if (state.isPreRoll && state.exerciseMeasures.length > 0) contentToDraw = state.exerciseMeasures[0];
            else if (state.exerciseStarted) contentToDraw = state.currentMeasureContent;
            drawMeasure(mainGroup, contentToDraw, 30, 360);
        }
        function drawMeasure(parentGroup, content, xOffset, measureWidth) {
            const clefInfo = notesData.clefs[ui.clefSelect.value];
            const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
            parentGroup.appendChild(group);
            for (let i = 0; i < 5; i++) {
                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute('x1', xOffset); line.setAttribute('y1', 40 + i * 10);
                line.setAttribute('x2', xOffset + measureWidth); line.setAttribute('y2', 40 + i * 10);
                line.setAttribute('stroke', '#000'); line.setAttribute('stroke-width', '1');
                group.appendChild(line);
            }
            let currentX = xOffset + 20;
            const clef = document.createElementNS("http://www.w3.org/2000/svg", "text");
            clef.textContent = clefInfo.symbol;
            clef.setAttribute('x', currentX);
            clef.setAttribute('y', clefInfo.symbolY);
            clef.setAttribute('font-size', '55px');
            clef.setAttribute('dominant-baseline', 'middle');
            group.appendChild(clef); currentX += 50;

            const keyInfo = notesData.keySignatures[state.keySignature];
            const currentClef = ui.clefSelect.value;
            if (keyInfo && keyInfo.count > 0 && !ui.keySigContainer.classList.contains('hidden')) {
                const positions = keyInfo.type === 'sharp' ? notesData.sharpPositions[currentClef] : notesData.flatPositions[currentClef];
                const symbol = keyInfo.type === 'sharp' ? '♯' : '♭';
                const fontSize = '32px';
                for (let i = 0; i < keyInfo.count; i++) {
                    const accidental = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    accidental.setAttribute('x', currentX);
                    accidental.setAttribute('y', positions[i]);
                    accidental.setAttribute('font-size', fontSize);
                    accidental.setAttribute('dominant-baseline', 'middle');
                    accidental.textContent = symbol;
                    group.appendChild(accidental);
                    currentX += 12;
                }
                currentX += 15; 
            }

            const timeSigParts = ui.timeSigSelect.value.split('/');
            const timeSigTop = document.createElementNS("http://www.w3.org/2000/svg", "text");
            timeSigTop.setAttribute('x', currentX); timeSigTop.setAttribute('y', 55);
            timeSigTop.setAttribute('font-size', '32px');
            timeSigTop.textContent = timeSigParts[0];
            group.appendChild(timeSigTop);
            const timeSigBottom = document.createElementNS("http://www.w3.org/2000/svg", "text");
            timeSigBottom.setAttribute('x', currentX); timeSigBottom.setAttribute('y', 85);
            timeSigBottom.setAttribute('font-size', '32px');
            timeSigBottom.textContent = timeSigParts[1];
            group.appendChild(timeSigBottom); currentX += 35;

            if(!content || content.length === 0) return;
            const noteSpacing = (measureWidth - (currentX - xOffset) - 20) / content.length;
            const noteStartX = currentX + noteSpacing / 2;
            state.noteStartX = noteStartX;
            state.noteSpacing = noteSpacing;

            const americanChordLabels = [];
            if (state.showNoteNames) {
                let lastLabel = null;
                let yLevel = 0; // 0 for high, 1 for low
                content.forEach((item, index) => {
                    const isChord = Array.isArray(item);
                    const cipherType = state.cipherType;
                    if (isChord && item.length > 2 && (cipherType === 'americano' || cipherType === 'todos')) {
                        const chordInfo = getChordName(item);
                        if (chordInfo.name) {
                            const itemX = noteStartX + index * noteSpacing;
                            const estimatedWidth = chordInfo.name.length * 10;
                            let currentLabel = { text: chordInfo.name, x: itemX, y: -5, left: itemX - estimatedWidth / 2, right: itemX + estimatedWidth / 2 };
                            if (lastLabel && currentLabel.left < lastLabel.right + 10) { yLevel = 1 - yLevel; } else { yLevel = 0; }
                            currentLabel.y = -5 + (yLevel * 20);
                            americanChordLabels.push(currentLabel);
                            lastLabel = currentLabel;
                        } else { lastLabel = null; }
                    } else { lastLabel = null; }
                });
            }

            americanChordLabels.forEach(label => {
                const nameText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                nameText.textContent = label.text;
                nameText.setAttribute('x', label.x);
                nameText.setAttribute('y', label.y);
                nameText.setAttribute('font-size', '20px');
                nameText.setAttribute('fill', 'black');
                nameText.setAttribute('text-anchor', 'middle');
                group.appendChild(nameText);
            });

            const activeAccidentalsInMeasure = {};

            content.forEach((item, index) => {
                if (!item || item.length === 0) return;
                const isChord = Array.isArray(item);
                const notes = isChord ? item.sort((a,b) => notesData.all.indexOf(b) - notesData.all.indexOf(a)) : [item];
                const itemX = noteStartX + index * noteSpacing;
                let noteObjects = notes.map(note => {
                    const noteNameOnly = note.split('/')[0];
                    const octave = note.split('/')[1];
                    const baseLetter = noteNameOnly[0];
                    const lookupNote = `${baseLetter}/${octave}`;
                    return { note, y: clefInfo.yPositions[lookupNote] };
                }).filter(n => n.y !== undefined);
                
                if (noteObjects.length !== notes.length) { console.warn("Undefined note Y position for one of:", notes); return; } 
                
                if(state.showNoteNames) {
                    if (isChord) {
                        const cipherType = state.cipherType;
                        if (notes.length === 2) {
                            const intervalInfo = getIntervalAbbreviation(notes);
                            if (intervalInfo.name) {
                                const nameText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                                nameText.textContent = intervalInfo.name;
                                nameText.setAttribute('x', itemX);
                                nameText.setAttribute('y', 145);
                                nameText.setAttribute('font-size', '18px');
                                nameText.setAttribute('fill', 'black');
                                nameText.setAttribute('text-anchor', 'middle');
                                group.appendChild(nameText);
                            }
                        } else if (notes.length > 2) {
                            const chordInfo = getChordName(notes);
                            let bottomParts = [];
                            if ((notes.length === 3 || notes.length === 4) && (cipherType === 'bajo' || cipherType === 'todos')) {
                                bottomParts = chordInfo.figuredBass || [];
                            } else if (notes.length === 4 && (cipherType === 'drops' || cipherType === 'todos')) {
                                const voicingText = notesData.voicingAbbreviations[item.voicing];
                                if (voicingText) {
                                    bottomParts = [voicingText];
                                }
                            }
                            
                            if (bottomParts.length > 0) {
                                bottomParts.forEach((part, i) => {
                                    const textElem = document.createElementNS("http://www.w3.org/2000/svg", "text");
                                    textElem.textContent = part;
                                    textElem.setAttribute('x', itemX);
                                    textElem.setAttribute('y', 138 + i * 15);
                                    textElem.setAttribute('font-size', '18px');
                                    textElem.setAttribute('fill', 'black');
                                    textElem.setAttribute('text-anchor', 'middle');
                                    group.appendChild(textElem);
                                });
                            }
                        }
                    } else { // It's melody
                        const fullNoteName = notes[0].split('/')[0];
                        const baseNoteName = fullNoteName.slice(0, 1);
                        let latinName = notesData.noteToLatin[baseNoteName];

                        if (state.melodyNoteNameStyle === 'con-alteracion') {
                            const accidental = fullNoteName.slice(1);
                            if (accidental) {
                                latinName += accidental;
                            }
                        }
                        
                        if (latinName) {
                            const nameText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            nameText.textContent = latinName;
                            nameText.setAttribute('x', itemX);
                            nameText.setAttribute('y', 145); // Below the staff
                            nameText.setAttribute('font-size', '18px');
                            nameText.setAttribute('fill', 'black');
                            nameText.setAttribute('text-anchor', 'middle');
                            group.appendChild(nameText);
                        }
                    }
                }
                
                const accidentalsToDraw = [];

                noteObjects.forEach(({note, y}) => {
                    let symbolToDraw = null;
                    const noteName = note.split('/')[0];
                    const noteLetter = noteName.slice(0, 1);
                    const requiredAccidental = noteName.length > 1 ? noteName.slice(1) : '';
                    
                    const keyNotes = notesData.keySignatures[state.keySignature].notes;
                    const noteInKey = keyNotes.find(n => n.startsWith(noteLetter));
                    const keyAccidental = noteInKey && noteInKey.length > 1 ? noteInKey.slice(1) : '';

                    const currentAccidentalInMeasure = activeAccidentalsInMeasure[noteLetter] === undefined ? keyAccidental : activeAccidentalsInMeasure[noteLetter];
                    
                    if (requiredAccidental !== currentAccidentalInMeasure) {
                        if (requiredAccidental === '#') symbolToDraw = '♯';
                        else if (requiredAccidental === 'b') symbolToDraw = '♭';
                        else if (requiredAccidental === '##') symbolToDraw = '𝄪';
                        else if (requiredAccidental === 'bb') symbolToDraw = '𝄫';
                        else symbolToDraw = '♮';
                        activeAccidentalsInMeasure[noteLetter] = requiredAccidental;
                    }

                    if (symbolToDraw) {
                        accidentalsToDraw.push({ symbol: symbolToDraw, y: y });
                    }
                });

                let lastY = -1000;
                noteObjects.forEach(({note, y}) => {
                    let headX = itemX;
                    if(isChord && Math.abs(y - lastY) <= 5) {
                        headX = itemX + 12;
                    }
                    const noteHead = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
                    noteHead.setAttribute('cx', headX); noteHead.setAttribute('cy', y);
                    noteHead.setAttribute('rx', '6'); noteHead.setAttribute('ry', '4.5');
                    noteHead.setAttribute('transform', `rotate(-15, ${headX}, ${y})`);
                    noteHead.setAttribute('fill', '#000');
                    group.appendChild(noteHead); lastY = y;
                    for(let ly = 40; ly >= y; ly -= 10) if(ly < 40) drawLedgerLine(group, headX, ly);
                    for(let ly = 80; ly <= y; ly += 10) if(ly > 80) drawLedgerLine(group, headX, ly);
                });

                if (accidentalsToDraw.length > 0) {
                    accidentalsToDraw.sort((a, b) => a.y - b.y);
                    let columnAssignments = [];
                    for(let i = 0; i < accidentalsToDraw.length; i++) {
                        let currentAcc = accidentalsToDraw[i];
                        let assignedColumn = 0;
                        let placed = false;
                        while(!placed) {
                            let clash = false;
                            for(let j = 0; j < i; j++) {
                                if(columnAssignments[j] === assignedColumn) {
                                    let prevAcc = accidentalsToDraw[j];
                                    if (Math.abs(currentAcc.y - prevAcc.y) < 15) { // 15 is a magic number for vertical clearance
                                        clash = true;
                                        break;
                                    }
                                }
                            }
                            if (!clash) {
                                columnAssignments[i] = assignedColumn;
                                placed = true;
                            } else {
                                assignedColumn++;
                            }
                        }
                    }
                    accidentalsToDraw.forEach((acc, i) => {
                        const xPos = (itemX - 30) - (columnAssignments[i] * 15); // Stagger columns leftward
                        const accidentalText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        accidentalText.textContent = acc.symbol;
                        accidentalText.setAttribute('x', xPos);
                        accidentalText.setAttribute('y', acc.y);
                        accidentalText.setAttribute('font-size', '30px');
                        accidentalText.setAttribute('dominant-baseline', 'middle');
                        group.appendChild(accidentalText);
                    });
                }
            });
        }
        function drawLedgerLine(parent, x, y){
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute('x1', x - 10); line.setAttribute('y1', y);
            line.setAttribute('x2', x + 10); line.setAttribute('y2', y);
            line.setAttribute('stroke', 'black'); line.setAttribute('stroke-width', '1');
            parent.appendChild(line);
        }
        
        const tutorialSteps = [
             {
                id: 'main-content',
                text: '<h2 class="text-2xl font-bold text-emerald-400">¡Bienvenido a Lectura a Primera Vista!</h2><p>Esta aplicación está pensada principalmente para guitarristas, pero es una herramienta versátil para cualquier músico.</p><p class="mt-2">La sección de <strong>Melodía</strong> y la <strong>Armonía a 2 voces (intervalos)</strong> están disponibles en clave de Sol, Fa y Do, siendo útiles para cualquier instrumento o para practicar solfeo.</p><p class="mt-2">La <strong>Armonía a 3 y 4 voces</strong> ha sido diseñada específicamente con la guitarra en mente, por lo que estos ejercicios solo están disponibles en <strong>clave de Sol</strong>.</p><p class="mt-4">¡Vamos a explorar cómo funciona!</p>'
            },
            {
                id: 'exercise-type-control',
                text: '<h3><strong>1. Tipo de Ejercicio</strong></h3><p>Primero, elige tu modo de práctica:</p><ul><li class="mt-2"><strong>Melodía:</strong> Practica la lectura de notas individuales, una tras otra.</li><li class="mt-2"><strong>Armonía:</strong> Practica la lectura de varias notas sonando al mismo tiempo.</li></ul>'
            },
            {
                id: 'harmony-options-container',
                text: '<h3><strong>2. Opciones de Armonía</strong></h3><p>Si eliges <strong>Armonía</strong>, aparecerán nuevas opciones:</p><ul><li class="mt-2"><strong>Notas:</strong> Define cuántas notas simultáneas leerás. <strong>2</strong> para intervalos, <strong>3</strong> para tríadas (acordes de 3 notas) y <strong>4</strong> para cuatríadas (acordes de 7ma).</li><li class="mt-2"><strong>Filtros específicos:</strong> Según las notas que elijas, podrás filtrar por tipos de intervalos, acordes, inversiones o voicings que quieras practicar.</li></ul>'
            },
            {
                id: 'difficulty-select',
                text: '<h3><strong>3. Nivel de Dificultad</strong></h3><p>Ajusta la complejidad del ejercicio:</p><ul><li class="mt-2"><strong>Básico:</strong> Rango de notas limitado y saltos melódicos pequeños.</li><li class="mt-2"><strong>Medio:</strong> Un rango más amplio y saltos más desafiantes.</li><li class="mt-2"><strong>Avanzado:</strong> Todo el rango del instrumento con saltos complejos e inesperados.</li></ul>'
            },
            {
                id: 'clef-select',
                text: `<h3><strong>4. Configuración del Pentagrama</strong></h3><p>Personaliza la escritura musical:</p><ul><li class="mt-2"><strong>Clave:</strong> Elige entre Sol, Fa y Do.</li><li class="mt-2"><strong>Armadura:</strong> Selecciona la tonalidad del ejercicio (disponible solo en modo Melodía).</li><li class="mt-2"><strong>Compás:</strong> Define el compás (4/4, 3/4, 2/4).</li></ul><div class="mt-4 p-2 bg-sky-800 rounded-md text-sm"><p><strong>🧠 Trabajo Mental en Armonía:</strong></p><p class="mt-1">El modo <strong>Armonía</strong> siempre se muestra sin armadura (Do Mayor), pero el verdadero ejercicio es mental. Imagina que estás en otra tonalidad. Por ejemplo, si decides practicar en <strong>Re Mayor</strong>, debes leer todas las notas F y C como si fueran F♯ y C♯. Si piensas en <strong>Mi♭ Mayor</strong>, las notas B, E y A se convierten en Si♭, Mi♭ y La♭. ¡Este es el núcleo del entrenamiento!</p></div><p class="mt-4 p-2 bg-zinc-600 rounded-md text-sm"><strong>Nota Importante:</strong> La app está optimizada para móviles y tablets. Si en tu computadora las claves no se ven en la línea correcta (Sol en 2ª, Fa en 4ª, Do en 3ª), es debido a diferencias de renderizado de fuentes entre sistemas operativos.</p>`
            },
            {
                id: 'tempo',
                text: '<h3><strong>5. Duración y Velocidad</strong></h3><ul><li class="mt-2"><strong>Tempo (BPM):</strong> Establece la velocidad del metrónomo en pulsos por minuto.</li><li class="mt-2"><strong>Compases:</strong> Elige cuántos compases durará el ejercicio. Puedes seleccionar un valor predefinido o "Personalizado" para escribir tu propio número.</li></ul>'
            },
            {
                id: 'change-beat-control',
                text: '<h3><strong>6. Lectura Adelantada</strong></h3><p>Esta es una herramienta clave para forzarte a leer más adelante. Por defecto, el siguiente compás aparece en el tiempo 1. Si cambias <strong>"Cambiar compás en"</strong> a un tiempo anterior (por ejemplo, al tiempo 3 en un 4/4), el pentagrama con las nuevas notas se dibujará antes de que termine el compás actual.</p><p class="mt-2">Esto te obliga a despegar la vista de lo que estás tocando y a procesar lo que viene, una habilidad crucial para la lectura a primera vista fluida.</p>'
    
            },
            {
                id: 'show-note-names',
                text: '<h3><strong>7. Ayudas Visuales</strong></h3><p>Activa estas opciones para facilitar la lectura:</p><ul><li class="mt-2"><strong>Nombres:</strong> Muestra el nombre de las notas o el cifrado de los acordes debajo del pentagrama.</li><li class="mt-2"><strong>Guía:</strong> Muestra una línea vertical que se mueve pulso a pulso, ayudándote a no perderte.</li></ul>'
            },
            {
                id: 'startStopButton',
                text: '<h3><strong>8. Controles y Atajos</strong></h3><p>Usa los botones o atajos para manejar el ejercicio:</p><ul><li class="mt-2"><strong>Botones:</strong> Inicia, pausa o detén el ejercicio.</li><li class="mt-2"><strong>Clics:</strong> Un clic en el pentagrama inicia o pausa, doble clic detiene.</li><li class="mt-2"><strong>Barra Espaciadora:</strong> Inicia/Pausa (un toque) y Detiene (doble toque).</li><li class="mt-2"><strong>F:</strong> Activa/Desactiva el modo de pantalla completa.</li><li class="mt-2"><strong>N:</strong> Muestra/Oculta los nombres de las notas.</li><li class="mt-2"><strong>G:</strong> Muestra/Oculta la guía de lectura.</li><li class="mt-2"><strong>C:</strong> Cambia entre las claves de Sol, Fa y Do.</li></ul>'
            },
            {
                id: 'main-content',
                text: '<h2 class="text-2xl font-bold text-emerald-400">¡Todo Listo!</h2><p>Ya conoces todas las funciones. Configura tu ejercicio ideal y ¡a mejorar esa lectura! La práctica constante es la clave.</p>'
            }
        ];

        let currentTutorialStep = 0;
        function showTutorial() {
            currentTutorialStep = 0;
            ui.tutorialModal.classList.remove('hidden');
            updateTutorialStep();
        }
        function hideTutorial() {
            ui.tutorialModal.classList.add('hidden');
            ui.tutorialHighlight.classList.add('hidden');
        }
        function nextTutorialStep() {
            currentTutorialStep++;
            if (currentTutorialStep >= tutorialSteps.length) {
                hideTutorial();
            } else {
                updateTutorialStep();
            }
        }
         function prevTutorialStep() {
            currentTutorialStep--;
            if (currentTutorialStep < 0) {
               currentTutorialStep = 0;
            }
            updateTutorialStep();
        }
        function updateTutorialStep() {
            const step = tutorialSteps[currentTutorialStep];
            ui.tutorialStepsContainer.innerHTML = `<div class="tutorial-step active">${step.text}</div>`;
            ui.tutorialStepCounter.textContent = `${currentTutorialStep + 1} / ${tutorialSteps.length}`;

            ui.prevTutorialStepBtn.classList.toggle('hidden', currentTutorialStep === 0);
             if (currentTutorialStep === tutorialSteps.length - 1) {
                ui.nextTutorialStepBtn.textContent = 'Finalizar';
            } else {
                ui.nextTutorialStepBtn.textContent = 'Siguiente';
            }

            
            const targetElement = document.getElementById(step.id);
            if (targetElement) {
                const rect = targetElement.getBoundingClientRect();
                const highlight = ui.tutorialHighlight;
                highlight.style.left = `${rect.left - 10}px`;
                highlight.style.top = `${rect.top - 10}px`;
                highlight.style.width = `${rect.width + 20}px`;
                highlight.style.height = `${rect.height + 20}px`;
                highlight.style.boxShadow = '0 0 0 9999px rgba(0, 0, 0, 0.7)';
                highlight.classList.remove('hidden');
            } else {
                ui.tutorialHighlight.classList.add('hidden');
            }
        }
    </script>
</body>
</html>


